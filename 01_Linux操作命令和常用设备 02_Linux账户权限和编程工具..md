### 1.Linux系统：

多进程、多用户,多用于服务器、个人电脑、嵌入式设备

#### 1.1Linux框架结构： 

![image-20251225194342377](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20251225194342377.png)

**一切皆文件**



### 2.文件操作常用命令

pwd 查看当前目录所在的绝对路径

cd：改变当前工作路径

1. “~”：表示跳到用户的home目录

2. “.”：表示当前所在目录
3. “..”：表示上一层目录

mkdir 创建目录

rmdir 只能删除空文件夹，不能删除非空文件夹

**rm 命令**：用于删除文件或目录。

1. **-r 参数**：表示递归删除，即删除目录及其下的所有子目录和文件。
2. **-f 参数**：表示强制删除，无需确认，即使文件是只读的也会直接删除。
3. -d 参数：删除空目录，效果等同于 rmdir

**ls 命令**：列出目录内容

1. **-l 参数**：长格式显示，包含权限、所有者、大小、时间
2. **-a 参数**：显示所有文件，包括隐藏文件（以`.`开头）
3. **-h 参数**：与-l搭配，人性化显示文件大小（K、M、G）
4. **-t 参数**：按修改时间排序，最新在前
5. **-r 参数**：反向排序

------

**cp 命令**：复制文件或目录

1. **-r 参数**：递归复制，用于复制目录
2. **-i 参数**：覆盖前询问确认
3. **-v 参数**：显示复制过程信息
4. **-p 参数**：保留文件属性（权限、时间等）
5. **-u 参数**：只复制更新的文件（增量备份）

------

**mv 命令**：移动或重命名文件/目录

1. **-i 参数**：覆盖前询问确认
2. **-v 参数**：显示移动过程信息
3. **-u 参数**：只移动更新的文件
4. **-n 参数**：不覆盖已存在的文件
5. **-b 参数**：覆盖前创建备份（加`~`后缀）

------

**rename 命令：批量重命名文件**

常用参数：

- **`-n`**：试运行，只显示会发生的更改（不实际执行）
- **`-v`**：显示重命名详情

基本用法：

```bash
rename 's/原模式/新模式/' 文件
```



实用示例：

1. 更改文件扩展名

```bash
rename 's/.txt/.md/' *.txt    # 将所有.txt文件改为.md
rename 's/.JPG/.jpg/' *.JPG   # 统一扩展名大小写
```



2. 添加/删除前缀

```bash
rename 's/^/前缀_/' *.jpg      # 在所有jpg前加"前缀_"
rename 's/旧前缀_//' *         # 删除"旧前缀_"
```



3. 批量替换

```bash
rename 's/图片/photo/' *      # 将"图片"替换为"photo"
rename 's/ /_/g' *            # 将所有空格替换为下划线
```



4. 使用-n预览

```bash
rename -n 's/.log/.bak/' *.log  # 预览将.log改为.bak
rename -v 's/test_//' *        # 执行并显示详情
```



------

**find 命令：查找文件/目录**

常用参数：

- **`-name`**：按文件名查找
- **`-type`**：按类型查找（f=文件，d=目录）
- **`-mtime`**：按修改时间查找
- **`-size`**：按文件大小查找
- **`-exec`**：对找到的文件执行命令

实用示例：

1. 按名称查找

```bash
find . -name "*.txt"            # 查找当前目录所有txt文件
find /home -name "config*"      # 在/home中查找config开头的文件
find . -iname "readme*"         # 不区分大小写查找
```



2. 按类型查找

```bash
find . -type f                  # 查找所有文件
find /tmp -type d               # 查找/tmp下所有目录
find . -type f -name "*.jpg"    # 查找jpg文件
```



3. 按时间查找

```bash
find . -mtime -1               # 1天内修改的文件
find /var/log -mtime +7        # 7天前修改的文件
find . -newer 参考文件         # 比参考文件新的文件
```



4. 按大小查找

```bash
find . -size +10M              # 大于10MB的文件
find . -size -100k             # 小于100KB的文件
find . -size 0                 # 空文件
```



5. 组合查找

```bash
find . -type f -name "*.log" -size +10M    # 大于10MB的log文件
find /home -type f -name "*.tmp" -mtime +30  # 30天前的tmp文件
```



6. 执行命令

```bash
find . -name "*.tmp" -delete               # 删除所有tmp文件
find . -name "*.log" -exec cp {} /backup   # 复制log文件到备份目录
find . -type f -exec chmod 644 {}          # 修改所有文件权限为644
```



### 3. 注：在各目录中以颜色区分不同的文件类型

蓝：目录；
绿：可执行文件；
红：压缩文件；
浅蓝：链接文件；
灰：其他文件；
红底白字：错误的链接文件

#### 3.1 各文件类型缩写：

(d：目录，c：字符文件、b：块设备文件、l：链接、p：管道文件，-：普通文件）

#### 3.2 目录结构

/bin 命令
/usr用户的很多应用程序和库都存放在这个目录下
/lib动态链接库
/dev外部设备映射文件
/home用户名对应的目录
/opt第三方安装软件
/etc系统管理的各种配置文件和子目录

#### 3.2 Linux用户类别

**root：**这是系统特权用户类，他们都有访问root登录帐号的权限
**owner：**这是实际拥有文件的用户。
**group: ** 这是共享文件的组访问权的用户类的用户组名称
**world：** 这是不属于上面3类的所有其他用户。



### 4. 遇到问题1：使用MobaXterm图形化upload失败

![image-20251227115738786](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20251227115738786.png)

原因：我是以普通用户远程连接的虚拟机，即使后续su root，对一些文件夹也没有写入权限
1.可以su root，修改目标目录权限

```bash
# chmod a+w：chmod是修改权限的命令，a+w表示给所有用户（a） 增加写入（w） 权限。
sudo chmod a+w 目录名
```

2.上传到**有写入权限的地方**，比如**家目录**（/home/你的用户名）
然后用 mv 移动

![image-20251227120711326](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20251227120711326.png)



### 5.一些常用命令补充

| 命令                 | 作用                                        |
| -------------------- | ------------------------------------------- |
| `cat`                | 查看文件内容，会把文件内容输出到终端上      |
| `tail`               | 查看文件末尾 10 行（默认）                  |
| `tail  -n 20 文件名` | 查看文件末尾 20 行                          |
| `tail -f 文件名`     | 实时追踪文件新增内容（常用于看日志）        |
| `ps`                 | 查看当前终端的进程                          |
| `ps -a`              | 查看所有终端的进程                          |
| `ps aux`             | 查看系统所有进程（含详细信息：CPU、内存等） |

| 命令             | 作用                                       |
| ---------------- | ------------------------------------------ |
| `ls xxx*`        | 列出以 xxx **开头**的文件                  |
| `ls *.c`         | 列出以 .c **结尾**的文件                   |
| `ls aa[1-9].txt` | 列出 aa1.txt ~ aa9.txt（**包含指定范围**） |
| `ls [^a]*`       | 列出**不以 a 开头**的文件                  |



### 6.输入输出重定向

| 符号 | 作用                     |
| ---- | ------------------------ |
| `>`  | 输出重定向（覆盖写入）   |
| `>>` | 输出重定向（追加写入）   |
| `<`  | 输入重定向（从文件读取） |

```bash
"hello" > a.txt    # 写入文件（覆盖）
"world" >> a.txt   # 追加到文件末尾
cat < a.txt             # 从文件读取内容


```



### 7.pipe管道

问题背景

​	假设你想：**统计 /usr/bin 目录下有多少个文件**

​	**传统做法（需要临时文件）：**	

```bash
ls /usr/bin > result.txt   # 第1步：把ls结果写入文件
wc -w < result.txt         # 第2步：从文件读取并统计
```

这样需要创建一个临时文件 result.txt，很麻烦！

用管道就能一行搞定！

```bash
ls /usr/bin | wc -w
```

**一行搞定！**

- `|` 就是管道符
- 把**左边命令的输出**直接传给**右边命令作为输入**
- 不需要中间文件



总结

​	 **管道`|`** *= 前一个命令的输出 → 后一个命令的输入*



### **grep 命令精讲**

核心功能

**在文件中搜索匹配指定模式的行**

常用选项

1. **`-n`**：显示匹配行的行号
2. **`-i`**：忽略大小写
3. **`-v`**：反向匹配（显示不匹配的行）
4. **`-c`**：只统计匹配的行数



1. `grep -n '^xxx' filename`

- **功能**：查找以"xxx"开头的行
- **解释**：`^`表示行开头
- **示例**：`grep -n '^Hello' file.txt` 找到以Hello开头的行

2. `grep -n 'xxx$' filename`

- **功能**：查找以"xxx"结尾的行
- **解释**：`$`表示行结尾
- **示例**：`grep -n 'world$' file.txt` 找到以world结尾的行

3. `grep -n '^$' filename`

- **功能**：查找空行
- **解释**：`^$`表示行开头直接到行结尾，中间没内容
- **示例**：`grep -n '^$' file.txt` 找到所有空行

4. `grep -n 'xx' filename`

- **功能**：查找包含"xx"的行
- **解释**：最简单的查找，找到包含xx的任意位置
- **示例**：`grep -n 'error' log.txt` 找到包含error的行

5. `ll /usr/lib > result.txt`

- **功能**：将`/usr/lib`目录的详细列表保存到result.txt文件
- **解释**：`ll`是`ls -l`的别名，`>`表示重定向输出到文件



### 8.压缩与解压

**为什么有时用 gunzip，有时用 tar？**

| 工具            | 功能      | 处理对象          |
| --------------- | --------- | ----------------- |
| **gzip/gunzip** | 只能压缩  | **单个文件**      |
| **tar**         | 打包+压缩 | **多个文件/目录** |



```
情况1：单个文件
   test.c  ──gzip──>  test.c.gz  ──gunzip──>  test.c

情况2：多个文件/目录
   目录text/  ──tar打包──>  text.tar  ──gzip压缩──>  text.tar.gz
              (多变一)              (压缩)
```

**所以：**

- `.gz` 文件 → 用 `gunzip` 解压
- `.tar.gz` 文件 → 用 `tar -zxvf` 解压（先解压再解包）
- `.tar.bz2` 文件 → 用 `tar -jxvf` 解压

#### **gzip/gunzip（单文件）**

| 命令               | 作用             |
| :----------------- | :--------------- |
| `gzip test.c`      | 压缩 → test.c.gz |
| `gunzip test.c.gz` | 解压 → test.c    |

#### tar（打包+压缩）

x.tar、x.tar.gz、x.tar.bz2 是你的某个文件名

| 命令                       | 作用                              |
| :------------------------- | :-------------------------------- |
| `tar -cvf x.tar 目录`      | 打包                              |
| `tar -xvf x.tar`           | 解包                              |
| `tar -zcvf x.tar.gz 目录`  | 打包并压缩(gzip)        常用      |
| `tar -zxvf x.tar.gz`       | 解压(gzip)                   常用 |
| `tar -jcvf x.tar.bz2 目录` | 打包并压缩(bzip2)                 |
| `tar -jxvf x.tar.bz2`      | 解压(bzip2)                       |





### 9.文件的基础属性

#### 9.1 文件属性解读

使用 `ls -l`命令可以查看文件的详细信息

```
-rwxrw-r-- 1 root root 1024 Jan 1 12:00 test.txt
```

| 部分          | 含义                                      |
| ------------- | ----------------------------------------- |
| `-`           | 文件类型（`-`普通文件，`d`目录，`l`链接） |
| `rwxrw-r--`   | 权限（9位）                               |
| `1`           | 硬链接数                                  |
| `root`        | 所有者（owner）                           |
| `root`        | 所属组（group）                           |
| `1024`        | 文件大小（字节）                          |
| `Jan 1 12:00` | 最后修改时间                              |
| `test.txt`    | 文件名                                    |

#### 9.2 权限详解

权限分为三组（各三位）

```
rwx   rw-   r--
 │     │     │
 │     │     └── 其他人（others）
 │     └──────── 所属组（group）
 └────────────── 所有者（owner）
```

| 权限     | 数字 | 常用组合                        |
| -------- | ---- | ------------------------------- |
| r (读)   | 4    | `755` = rwxr-xr-x（可执行文件） |
| w (写)   | 2    | `644` = rw-r--r--（普通文件）   |
| x (执行) | 1    | `777` = rwxrwxrwx（完全开放）   |





#### 9.3 修改权限的命令

数字方式（推荐）

```bash
chmod 755 file      # rwxr-xr-x
chmod 644 file      # rw-r--r--
```

符号方式

```bash
chmod u+x file      # 给所有者加执行权限
chmod g-w file      # 去掉组的写权限
chmod o=r file      # 其他人只有读权限
chmod a+x file      # 所有人加执行权限
```

| 符号 | 含义          |
| ---- | ------------- |
| u    | user 所有者   |
| g    | group 所属组  |
| o    | others 其他人 |
| a    | all 所有人    |



#### 核心命令

| 命令    | 作用     | 示例               |
| ------- | -------- | ------------------ |
| `chmod` | 改权限   | `chmod 755 file`   |
| `chown` | 改所有者 | `chown user file`  |
| `chgrp` | 改所属组 | `chgrp group file` |

 简单解释
![image-20251229154251266](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20251229154251266.png)	

### 一些课堂案例（创建或删除组、用户 ）



创建组：addgroup groupname
创建用户并设置默认组：adduser username
向组添加用户：adduser username groupname或gpasswd -a username groupname
给用户设置密码：passwd username
删除组：delgroup groupname
删除普通用户：userdel -r username(把对应的home下的目录也会删掉）
将用户从组删除：deluser username groupname

对上述命令的实战

1.创建两个用户userauserb
2.创建一个文件夹以及内部的文件对于其他用户都都有可读可写权限
3.usera创建一个main.c
4.userb修改main.c打印helloword
5.usera编译main.c运行可执行文件





### 10.vim

| 按键                         | 功能         |
| ---------------------------- | ------------ |
| `i`                          | 插入模式     |
| `Esc`                        | 返回命令模式 |
| `:wq`                        | 保存退出     |
| `:q!`                        | 强制退出     |
| `/关键字`，按 `n` 查找下一个 | 搜索字符串   |



### 11.GCC编译过程

```
.c ──E──>   .i    ──S──>  .s   ──c──>  .o   ──链接──> 可执行
预处理       编译          汇编          链接
```

| 参数 | 记忆                 | 作用           |
| ---- | -------------------- | -------------- |
| `-E` | **E**arly（最早）    | 只预处理       |
| `-S` | a**S**sembly（汇编） | 生成汇编       |
| `-c` | **c**ompile（编译）  | 只编译不链接   |
| `-o` | **o**utput（输出）   | 指定输出文件名 |

**最常用命令：** `gcc xxx.c -o xxx` *一步生成可执行文件*





### 12.静态库和动态库（共享库）

```
静态库：相当于把食谱抄到自己的笔记本里，以后不需要原书了
动态库：相当于记下图书馆书架位置，每次需要时去查阅
```

#### 12.1 静态库

静态库在**编译时**直接复制到可执行文件中，运行时不再需要库文件。

步骤1：创建静态库

| 选项     | 含义                       |
| -------- | -------------------------- |
| `-c`     | 只编译不链接，生成 .o 文件 |
| `ar rcs` | 打包成静态库               |

**命名规则：** `lib` + 库名 + `.a`

```bash
# 1. 编译成目标文件
g++ -c CList.cpp -o CList.o

# 2. 打包成静态库
ar rcs libCList.a CList.o

```

步骤2：使用静态库

```bash
g++ main.cpp -L./ -lCList -o main

# 运行：直接执行，不需要额外设置
./main

```

*静态库编译后，库文件就可以删除了，程序照样能运行*





#### 12.2 共享库

与静态库不同，共享库在**运行时**才加载，多个程序可以共享同一份库文件。

步骤1：创建共享库

| 选项      | 含义           |
| --------- | -------------- |
| `-shared` | 生成共享库格式 |
| `-fPIC`   | 生成位置无关码 |

**命名规则：** `lib` + 库名 + `.so`

```bash
# C语言版本
gcc test.c -shared -fPIC -o libTest.so

# C++版本
g++ -shared -fPIC CList.cpp -o libCList.so
```



步骤2：使用共享库

| 选项 | 含义                     | 示例               |
| ---- | ------------------------ | ------------------ |
| `-l` | 指定库名（去掉lib和.so） | `-lCList`          |
| `-L` | 指定库所在路径           | `-L./`（当前目录） |

```bash
# 编译 main.cpp，链接当前目录下的 libCList.so
g++ main.cpp -L./ -lCList -o main
# 在main所在目录下即可运行此文件
./main
```

命令：

```
g++ main.cpp -L./ -lCList -o main
     │        │    │       │
     │        │    │       └── 输出文件名：main
     │        │    └────────── 链接库：libCList.so（自动加lib和.so）
     │        └─────────────── 库的路径：当前目录
     └──────────────────────── 源文件

```



**步骤3：安装共享库到系统目录**

运行程序时可能报错：找不到共享库。所以，我们将**共享库放到系统目录**里，一劳永逸。

```bash
# 1. 复制到系统库目录     （移动到系统库目录也行，将cp换成mv就行）
sudo cp libCList.so /usr/lib/

# 2. 更新库缓存
sudo ldconfig

```

之后使用就简单了：

```bash
# 编译：不需要 -L 指定路径
g++ main.cpp -lCList -o main

# 运行：直接执行
./main
```



**常用系统库目录：**

| 目录             | 说明               |
| ---------------- | ------------------ |
| `/usr/lib`       | 标准库目录         |
| `/usr/local/lib` | 用户自装库（推荐） |





### 13.遇到问题2：为什么test1、test2是一个组的，权限也够，但test2编译不了？

![image-20251229175535356](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20251229175535356.png)

![image-20251229175541624](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20251229175541624.png)

![image-20251229175622820](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20251229175622820.png)





问题在于**目录权限**，不是文件权限！

![image-20251229175728536](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20251229175728536.png)

注意这里：目录的**所属组是 test1**，不是 test 组！（./指当前目录（project） ）

test2 用户属于 **test组**，但目录的组是 **test1组**，所以 test2 被当作"其他用户"处理，而其他用户只有 `r-x`（读和执行），**没有写权限**！

编译要生成 main 文件 = 在目录里**写入**，所以被拒绝。

解决方法：

```bash
# 方法1：把目录的组改成 test
chown test1:test /home/test/project

# 方法2：给其他用户加写权限（不推荐）
chmod 777 /home/test/project

```

 
